# Documentation

The following will outline, to some degree, how registration of content within `ModRegister` works. Generally speaking, the methods within this class are standard methods of registering content to the game.

Do not rely on this as a form of Forge documentation. This is simply one method of how to perform certain actions, and some things may require additional steps done elsewhere.

I have grouped these registration methods in a single class to simplify and unify my registry standards across my mods. Too, to provide single instructions for repeatitive tasks.

# Init
***
**For the future**:
Defining custom events will be possible and all defined events would be registered at this step.
***

Upon initialization (running the `Init()` function), the mod ID is supplied to the class from the mod that imports this library. For example, a mod named "gemstones" would supply its mod ID to this init function.

Too, all events defined within the library are registered.

***

# Item Groups
Also known as creative tabs.

Item groups aren't actually registered to the game like other content items. Instead, they are defined by class and are used when registering content elsewhere.

***

# Crops
Crops extend the `Block` class and are registered like any other block.

***

# Resources
I define resources as the collection of ores, materials, tools and other items that are mined or gathered to create various products.

**This content is WIP and I will exclude currently.**

***

# Blocks
I register blocks in a handful of ways, but it simplifies to the following:

```java
public static Block registerBlock(String name, Block block, ItemGroup group)
{
    BlockItem itemBlock = new BlockItem(block, new Item.Properties().tab(group));

    block.setRegistryName(name);
    itemBlock.setRegistryName(name);

    ForgeRegistries.BLOCKS.register(block);
    ForgeRegistries.ITEMS.register(itemBlock);

    return block;
}
```

This method takes three arguments: `name`, `block` and `group`.
`name` is the block name, such as "custom_block" or "spruce_wood_chair."
`block` is the block itself, as stated by the expected type of `Block`.
`group` is the creative tab the block should be registered to. If the block you are registering should not be obtainable in creative mode, exclude this parameter and remove the `.tab(group)` portion of the first line.

`BlockItem itemblock = ...` defines a new item based on the provided block.
When you create a new block, it doesn't actually have a "holdable" item until you create and register one. This is done by defining a `BlockItem` item based on the block you created. For this registry method, I use generic item properties. Because `BlockItem` takes in an argument of type `Item.Properties`, you can specify other item properties at this step. Too, you may choose to supply this property as an argument to the `registerBlock` method.

The next two lines are supplying the registry names for the block and new item. The provided name should be something simple like "my_block," which when supplied as the registry name, will become "mymod:my_block."

Because of this, be sure to provide all content you create with unique and well-defined names. Don't use generic, non-descriptive names like "block1" or "aaaaa."

Finally, we register the block and item to the game using the `ForgeRegistries.IForgeRegistry<T>.register` method.
For blocks we use `BLOCKS` and items `ITEMS`, where `T` is `Block` and `Item` respectively.

I dislike having to recall content from registries, so I suggest storing your registered content in a collection of key-value pairs, such as a `HashMap<String, T>`, where `T` is the content type. For blocks, `T` = `Block`.

Here are the available properties of a block as defined by the `Block.Properties` class:
* `Material` material
* `Function<BlockState, MaterialColor>` materialColor
* `boolean` hasCollision = true;
* `SoundType` soundtype = `SoundType.STONE`
* `ToIntFunction<BlockState>` lightEmission = `(BlockState x) -> { return 0; }`
* `float` explosionResistance
* `float` destroyTime
* `boolean` requiresCorrectToolForDrops
* `boolean` isRandomlyTicking
* `float` friction = 0.6f
* `float` speedFactor = 1.0f
* `jumpFactor` = 1.0f
* `ResourceLocation` drops
* `boolean` canOcclude = `true`
* `boolean` isAir
* `int` harvestLevel = -1
* `ToolType` harvestLevel
    * `net.minecraftforge.common.ToolType`
* `Supplier<ResourceLocation>` lootTableSupplier
    * `java.util.function.Supplier`

* `AbstractBlock.IExtendedPositionPredicate<EntityType<?>>` isValidSpawn = `(BlockState blockState, IBlockReader blockReader, BlockPos blockPos, EntityType<?> entityType) -> { return blockState.isFaceSturdy(blockReader, blockPos, Direction.UP) && blockState.getLightValue(blockReader, blockPos) < 14; }`

* `AbstractBlock.IPositionPredicate isRedstoneConductor` = `(BlockState blockState, IBlockReader blockReader, BlockPos blockPos) -> { return blockState.getMaterial().isSolidBlocking() && blockState.isCollisionShapeFullBlock(blockReader, blockPos); }`

* `AbstractBlock.IPositionPredicate` isSuffocating = `(BlockState blockState, IBlockReader blockReader, BlockPos blockPos) -> { return this.material.blocksMotion() && blockState.isCollisionShapeFullBlock(blockReader, blockPos); }`

* `AbstractBlock.IPositionPredicate` isViewBlocking = `this.isSuffocating`

* `AbstractBlock.IPositionPredicate` hasPostProcess = `(BlockState blockState, IBlockReader blockReader, BlockPos blockPos) -> { return false; }`

* `AbstractBlock.IPositionPredicate` emissiveRendering = `(BlockState blockState, IBlockReader blockReader, BlockPos blockPos) -> { return false; }`

* `boolean` dynamicShape;

***
# Items
Registering items is exactly the same as registering an `ItemBlock` as descirbed previously.

```java
public static Item registerItem(String name, Properties properties, ItemGroup group)
{
    Item item = new Item(properties.tab(group)).setRegistryName(name);

    ForgeRegistries.ITEMS.register(item);

    return item;
}
```

The argument `properties` defines the characteristics of your item.

Here are the available properties of an item as defined by the `Item.Properties` class:
* `int` maxStackSize = 64
* `int` maxDamage
* `Item` craftingRemainingItem
* `ItemGroup` category
* `Rarity` rarity = `Rarity.COMMON`
    * `net.minecraft.item.Rarity`
* `Food` foodProperties
* `boolean` isFireResistant
* `canRepair` = true
* `Map<ToolType, Integer>` toolClasses = `new HashMap<ToolType, Integer>`
    * `java.util.Map`
    * `java.util.HashMap`
    * `net.minecraftforge.common.ToolType`

* _`Supplier<Callable<ItemStackTileEntityRenderer>>` ister_
    * _`java.util.function.Supplier`_
    * _`java.util.concurrent.Callable`_
    * _`net.minecraft.client.renderer.tileentity.ItemStackTileEntityRenderer`_

Items cannot have damage and be considered stackable.
For a full definition of the `Item` class, see `net.minecraft.item`.

***
# Tools
***
**This is a WIP and should be considered incomplete.**
***

```java
// As defined using the ToolMaterial class within this library.
public static Item registerTool(String name, ToolMaterial toolMaterial, ToolType toolType, int level, ItemGroup group)
{
    // As defined by the ToolBase class within this library.
    ToolBase item = new ToolBase(toolMaterial.getProperties().tab(group), toolType, level);

    // As defined earlier by example.
    return registerItem(name, item);
}

// As defined using the ToolMaterial class within this library.
public static void registerTools(String name, ToolMaterial material, ItemGroup group)
{
    // As defined using the previous method.
    registerTool(name + "_pickaxe", material, ToolType.PICKAXE, material.level(), group);
}
```

***
# Foods
***
**This is a WIP and should be considered incomplete.**
***

```java
public static Food registerFoodNoItem(int hunger, float saturation)
{
    return (new Food.Builder()).saturationMod(saturation).nutrition(hunger).build();
}

public static Item registerFood(String name, int hunger, float saturation, ItemGroup group)
{
    Food food = (new Food.Builder()).saturationMod(saturation).nutrition(hunger).build();

    // As defined earlier by example.
    return registerItem(name, new Item.Properties().food(food), group);
}

// This can utilize the "registerFoodNoItem" method above as an argument for "food."
public static Item registerFood(String name, Food food, ItemGroup group)
{
    // As defined earlier by example.
    return registerItem(name, new Item.Properties().food(food), group);
}
```

***
# World Gen
***
**This is a WIP and should be considered incomplete.**
***

I'm not going to bother providing examples until they are well established and proven usable.

***
# Misc
### Paintings
```java
public static PaintingType registerPainting(String name, PaintingType painting)
{
    painting.setRegistryName(new ResourceLocation(mod_id, name));

    ForgeRegistries.PAINTING_TYPES.register(painting);

    return painting;
}
```

# Additional Help
For those not well experienced in Java, much of what was explained above may be a bit confusing. Allow me to hopefully clarify some things and provide some brief insight.

### Suppliers
When you are attempting to create or register something and you get an error asking for a type `Supplier`, it is simply asking for something in the format of `() -> something` such as `() -> new Item(new Item.Properties())`. This is known as a "lambda expression," otherwise known as an "arrow function." It is represented as `Supplier<T>` where `T` is the type of the the result, such as `Supplier<Item>`.

To provide a simpler example, in JavaScript (not to be confused with Java used here, but for the sake of example) you can provide functions in various ways.

```js
function foo(arg, callback) {...}
```

where `callback` is a parameter of type `function`, you can supply it as

```js
foo(arg, function() { return ... });

// or

foo(arg, () => { return ... });
```

This principle can be applied to `Supplier` in Java.

### Packages
You are not required to organize your code by category or group, but it does help during debugging and logical readability.

For instance, having multiple files dedicated to creating blocks alongside files dedicated to creating items is not a great idea. It would be wise to sort your block related files into a directory `blocks` and items in `items`, or something of the sort. As such, your package names will change for each of your files. If you are using a smart IDE, this should be done automatically or may ask you if you would like to update package names and imports.

If not, the naming scheme should be similar to `package com.github.yourname.modname.blocks;`, where the path is `./src/main/java/com/github/yourname/modname/blocks/...`. The package naming scheme may be different depending on your preferences, but generally speaking the first three values should be `com`, `group` and `you`. `github` is a more "generic" group name and can be replaced with whatever you would like. Too, `yourname` can be anything you would like, but usually defines the author. See here for documentation on Java naming conventions: https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html

### Enumerators
https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html

The best way to describe a Java `enum` is as a class of properties that do not change. Essentially, it acts as a "collection" of values of a common type. For example:

```java
public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
    THURSDAY, FRIDAY, SATURDAY 
}
```

Each day within `Day` is a constant and is referenced like `Day.SUNDAY`.

You can provide details to each enumerated value by supplying additional properties to the `enum`. 

```java
public enum Planet {
    MERCURY (3.303e+23, 2.4397e6),
    VENUS   (4.869e+24, 6.0518e6),
    EARTH   (5.976e+24, 6.37814e6),
    MARS    (6.421e+23, 3.3972e6),
    JUPITER (1.9e+27,   7.1492e7),
    SATURN  (5.688e+26, 6.0268e7),
    URANUS  (8.686e+25, 2.5559e7),
    NEPTUNE (1.024e+26, 2.4746e7);

    private final double mass;   // in kilograms
    private final double radius; // in meters
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }
    private double mass() { return mass; }
    private double radius() { return radius; }

    // universal gravitational constant  (m3 kg-1 s-2)
    public static final double G = 6.67300E-11;

    double surfaceGravity() {
        return G * mass / (radius * radius);
    }
    double surfaceWeight(double otherMass) {
        return otherMass * surfaceGravity();
    }
    public static void main(String[] args) {
        if (args.length != 1) {
            System.err.println("Usage: java Planet <earth_weight>");
            System.exit(-1);
        }
        double earthWeight = Double.parseDouble(args[0]);
        double mass = earthWeight/EARTH.surfaceGravity();
        for (Planet p : Planet.values())
           System.out.printf("Your weight on %s is %f%n",
                             p, p.surfaceWeight(mass));
    }
}
```

There are various examples of this style of enumeration throughout Minecraft.

### Annotations
https://docs.oracle.com/javase/tutorial/java/annotations/basics.html

Primarily:
https://docs.oracle.com/javase/tutorial/java/IandI/override.html

The `@Override` annotation will take an existing method and replace its body with whatever it is redefined to be. An example is shown in the next section.

If a class contains a method `a()`, and a second class extends the first class, you can redefine the method from the first class in the second class using `@Override a()`.


### Interfaces
https://www.w3schools.com/java/java_interface.asp

Interfaces are "abstract classes" that tend to have properties that may be shared across multiple classes without direct inheritance. That is, having a class `Truck` may extend a class `Automobile`, but we may have another class `Sedan` that extends `Automobile`.

If we have a method `horn()`, we may want to define the result for `Truck` differently than `Car`. To do so, we can provide an interface of generic, unset properties that we define later as needed.
`Machine`, for instance.

We can apply this interface to `Automobile` and define the `horn()` method within `Truck` and `Car` individually.

```java
public interface Machine {
    public Sound horn();
}

public class Automobile implements Machine {
    public Sound horn() {
        return Sound.NONE;
    }
}

public class Truck extends Automobile {
    @Override
    public Sound horn() {
        return Sound.HORN_TRUCK;
    }
}

public class Car extends Automobile {
    @Override
    public Sound horn() {
        return Sound.HORN_CAR;
    }
}
```

### Keywords
Some keywords are very important to know:

**Static** defines a method / class as being "unchanging," such that no other instance of it will ever be created. Static types are generally reserved for helper functions or build functions that do not require content initialization (you never do `new Class()` for static content). Consider static equal to "only one of this."

Static classes do not include a constructor.

**Final** defines a value as "unchanging" too, but in a different way. Final declares a property to be constant, meaning after it has an assigned value, at initialization, it will never change.

**Public** versus **Private**

Public declares a property as usable outside the class body. Private restricts the method as being only usable within the class body. By default, not providing either of these to a property will define it as private-like, where it is unreachable outside the class definition.

Public items should be limited to primarily constants and methods. All other things should be labeled private. If a value should be fetchable externally, a "getter" and / or "setter" method should be provided. For example:

```java
public class Student {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}
```

In this example, the name of the student is provided as a value in the constructor. After that point, the name cannot be changed, but it is able to be fetched using the `getName()` method. Notice how the constructor `Student(String name)` is public. At least one constructor should be made public for non-static classes.

You can always provide more than one constructor, but they must incorporate different parameter patterns.
That is:
```java
public class Foo {
    String a;

    public Foo(String x) {
        this.a = x;
    }

    public Foo(Integer x) {
        this.a = x.toString();
    }

    public Foo(String x, String y) {
        this.a = x + y;
    }
}
```

**Conditions** such as `if / else` statements should be reduced to a simplified form. There is a technique you may want to apply for such a thing called **Boolean Algebra.** It is best described as a reduction of comparisons.

https://www.symbolab.com/solver/boolean-algebra-calculator

To explain the symbols used:
∨ ( + ) means "or"
∧ ( * ) means "and"
¬ ( ' after ) means "not" and precedes the value.

These are written in Java as:
|| for "or"
&& for "and"
! for "not" and too precedes the value.

Thus:
`AB + C` = `(A * B) + C` = `(A ∧ B) ∨ C`
and
`AB' + C'` = `(A * B') + C'` = `(A ∧ ¬B) ∨ ¬C`
where ¬ denotes `true` becomes `false` and `false` becomes `true`.

Here is a table of conditional rules, where 1 = `true` and 0 = `false`:

| Law Name         | AND                           | OR                          |
|--------------|-------------------------------|-----------------------------|
| Identity     | 1 * A = A                     | 0 + A = A                   |
| Null         | 0 * A = 0                     | 1 + A = 1                   |
| Idempotent   | A * A = A                     | A + A = A                   |
| Inverse      | A * A' = 0                    | A + A' = 1                  |
| Commutative  | A * B = B * A                 | A + B = B + A               |
| Associative  | (A * B) * C = A * (B * C)     | (A + B) + C = A + (B + C)   |
| Distributive | A + B * C = (A + B) * (A + C) | A * (B + C) = A * B + A * C |
| Absorption   | A * (A + B) = A               | A + A * B = A               |
| De Morgan's  | (A * B)' = A' + B'            | (A + B)' = A'B'             |

Of these laws, consider De Morgan's the most important to remember.

***
**If you end up in a situation where you have more than 3 to 5 `if` statements, consider using a `switch` statement.**
https://www.w3schools.com/java/java_switch.asp

This will save a lot of execution time for long chains of "if this, else if this, else if this, etc..."

_Don't be like YandereDev... use a `switch` statement._
***